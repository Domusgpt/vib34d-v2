<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIB34D - 5 Canvas Architecture</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            color: #fff;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
        }
        
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(0, 0, 0, 0.9);
            border-bottom: 2px solid #00ffff;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
        }
        
        .system-selector {
            display: flex;
            gap: 10px;
        }
        
        .system-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .system-btn.active {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px #00ffff;
        }
        
        .canvas-container {
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
        }
        
        /* ONLY 5 CANVASES - SHARED BETWEEN ALL SYSTEMS */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #background-canvas { z-index: 1; }
        #shadow-canvas { z-index: 2; }
        #content-canvas { z-index: 3; }
        #highlight-canvas { z-index: 4; }
        #accent-canvas { z-index: 5; }
        
        .debug-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            font-size: 12px;
            border: 1px solid #00ffff;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="logo">VIB34D v3</div>
        <div class="system-selector">
            <button class="system-btn active" onclick="switchSystem('faceted')">ðŸ”· Faceted</button>
            <button class="system-btn" onclick="switchSystem('quantum')">ðŸŒŒ Quantum</button>
            <button class="system-btn" onclick="switchSystem('holographic')">âœ¨ Holographic</button>
            <button class="system-btn" onclick="switchSystem('polychora')">ðŸ”® Polychora</button>
        </div>
    </div>
    
    <div class="canvas-container">
        <!-- ONLY 5 CANVASES TOTAL - REUSED FOR ALL SYSTEMS -->
        <canvas id="background-canvas"></canvas>
        <canvas id="shadow-canvas"></canvas>
        <canvas id="content-canvas"></canvas>
        <canvas id="highlight-canvas"></canvas>
        <canvas id="accent-canvas"></canvas>
    </div>
    
    <div class="debug-info" id="debug">
        System: <span id="currentSystem">faceted</span><br>
        Canvases: <span id="canvasCount">5</span><br>
        WebGL Contexts: <span id="contextCount">0</span>
    </div>

    <script>
        // VIB34D v3 - 5 Canvas Architecture
        
        let currentSystem = 'faceted';
        const visualizers = new Map();
        const shaderPrograms = new Map();
        
        // Canvas IDs - same 5 for all systems
        const canvasIds = [
            'background-canvas',
            'shadow-canvas', 
            'content-canvas',
            'highlight-canvas',
            'accent-canvas'
        ];
        
        // System colors for testing
        const systemColors = {
            faceted: { r: 0, g: 1, b: 1 },      // cyan
            quantum: { r: 1, g: 0, b: 1 },      // magenta
            holographic: { r: 1, g: 0.5, b: 1 }, // pink
            polychora: { r: 0.5, g: 1, b: 1 }    // light cyan
        };
        
        // Initialize visualizers for each canvas
        function initializeVisualizers() {
            let contextCount = 0;
            
            canvasIds.forEach((canvasId, index) => {
                const canvas = document.getElementById(canvasId);
                const gl = canvas.getContext('webgl', {
                    alpha: true,
                    premultipliedAlpha: true,
                    antialias: false,
                    depth: false
                });
                
                if (gl) {
                    contextCount++;
                    
                    // Create visualizer with shader switching capability
                    const visualizer = {
                        canvas,
                        gl,
                        layerIndex: index,
                        programs: new Map(),
                        currentProgram: null
                    };
                    
                    // Initialize shaders for each system
                    ['faceted', 'quantum', 'holographic', 'polychora'].forEach(system => {
                        const program = createShaderProgram(gl, system, index);
                        if (program) {
                            visualizer.programs.set(system, program);
                        }
                    });
                    
                    visualizers.set(canvasId, visualizer);
                }
            });
            
            document.getElementById('contextCount').textContent = contextCount;
            console.log(`Initialized ${contextCount} WebGL contexts for 5 canvases`);
        }
        
        // Create shader program for a specific system and layer
        function createShaderProgram(gl, system, layerIndex) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, `
                attribute vec2 position;
                void main() {
                    gl_Position = vec4(position, 0.0, 1.0);
                }
            `);
            
            const color = systemColors[system];
            const intensity = 0.2 + layerIndex * 0.15;
            const alpha = 0.3 + layerIndex * 0.1;
            
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, `
                precision mediump float;
                uniform float time;
                uniform vec2 resolution;
                
                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution;
                    
                    // Different patterns for each system
                    float pattern;
                    
                    ${system === 'faceted' ? `
                        // Simple grid pattern
                        pattern = step(0.5, fract(uv.x * 10.0)) * step(0.5, fract(uv.y * 10.0));
                    ` : system === 'quantum' ? `
                        // Quantum lattice pattern
                        float t = time * 0.5;
                        pattern = sin(uv.x * 20.0 + t) * cos(uv.y * 20.0 + t);
                    ` : system === 'holographic' ? `
                        // Holographic wave pattern
                        float wave1 = sin(uv.x * 15.0 + time);
                        float wave2 = cos(uv.y * 15.0 + time * 1.3);
                        pattern = wave1 * wave2;
                    ` : `
                        // Polychora 4D projection pattern
                        float r = length(uv - 0.5);
                        pattern = sin(r * 30.0 - time * 2.0) * cos(atan(uv.y - 0.5, uv.x - 0.5) * 4.0);
                    `}
                    
                    vec3 color = vec3(${color.r}, ${color.g}, ${color.b});
                    color *= (0.5 + 0.5 * pattern) * ${intensity};
                    
                    gl_FragColor = vec4(color, ${alpha});
                }
            `);
            
            if (!vertexShader || !fragmentShader) return null;
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Shader link failed:', gl.getProgramInfoLog(program));
                return null;
            }
            
            // Store attribute/uniform locations
            program.positionLocation = gl.getAttribLocation(program, 'position');
            program.timeLocation = gl.getUniformLocation(program, 'time');
            program.resolutionLocation = gl.getUniformLocation(program, 'resolution');
            
            // Create vertex buffer
            program.buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1, 1, 1
            ]), gl.STATIC_DRAW);
            
            return program;
        }
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // Switch system - changes shaders, not canvases
        function switchSystem(system) {
            currentSystem = system;
            
            // Update UI
            document.querySelectorAll('.system-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase().includes(system));
            });
            
            document.getElementById('currentSystem').textContent = system;
            
            console.log(`Switched to ${system} system - using same 5 canvases with different shaders`);
        }
        
        // Render loop
        function render() {
            const time = Date.now() * 0.001;
            
            visualizers.forEach(visualizer => {
                const { gl, canvas, programs } = visualizer;
                const program = programs.get(currentSystem);
                
                if (!program) return;
                
                // Set viewport and clear
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                // Use program
                gl.useProgram(program);
                
                // Set uniforms
                gl.uniform1f(program.timeLocation, time);
                gl.uniform2f(program.resolutionLocation, canvas.width, canvas.height);
                
                // Bind vertex buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);
                gl.enableVertexAttribArray(program.positionLocation);
                gl.vertexAttribPointer(program.positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Enable blending
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                
                // Draw
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            });
            
            requestAnimationFrame(render);
        }
        
        // Resize handler
        function handleResize() {
            canvasIds.forEach(canvasId => {
                const canvas = document.getElementById(canvasId);
                const rect = canvas.getBoundingClientRect();
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
            });
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            handleResize();
            initializeVisualizers();
            render();
        });
        
        window.addEventListener('resize', handleResize);
        
        // Make switchSystem global
        window.switchSystem = switchSystem;
    </script>
</body>
</html>